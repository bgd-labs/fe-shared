{"version":3,"file":"bgd-fe-utils.cjs.production.min.js","sources":["../src/utils/localStorage.ts","../src/web3/connectors/impersonatedConnector.ts","../src/web3/connectors/index.ts","../src/web3/store/transactionsSelectors.ts","../src/web3/providers/Web3Provider.tsx","../src/web3/store/transactionsSlice.ts","../src/web3/store/walletSlice.ts"],"sourcesContent":["import { BaseTx, TransactionPool } from \"../web3/store/transactionsSlice\";\nimport { WalletType } from '../web3/connectors';\n\nexport enum LocalStorageKeys {\n  LastConnectedWallet = 'LastConnectedWallet',\n  TransactionPool = 'TransactionPool'\n}\n\nexport const setLocalStorageTxPool = <T extends BaseTx>(pool: TransactionPool<T>) => {\n  const stringifiedPool = JSON.stringify(pool);\n  localStorage.setItem(LocalStorageKeys.TransactionPool, stringifiedPool);\n};\n\nexport const getLocalStorageTxPool = () => {\n  return localStorage.getItem(LocalStorageKeys.TransactionPool)\n};\n\n\nexport const setLocalStorageWallet = (walletType: WalletType) => {\n  localStorage.setItem(LocalStorageKeys.LastConnectedWallet, walletType);\n};\n\nexport const deleteLocalStorageWallet = () => {\n  localStorage.removeItem(LocalStorageKeys.LastConnectedWallet);\n};","import { Connector, Actions } from \"@web3-react/types\";\nimport { ethers, providers } from \"ethers\";\n\nexport class ImpersonatedProvider extends providers.JsonRpcProvider {\n  private copyProvider: providers.JsonRpcProvider;\n  constructor(url: string) {\n    super(url);\n    this.copyProvider = new providers.JsonRpcProvider(url);\n  }\n  getSigner(address: string): ethers.providers.JsonRpcSigner {\n    return this.copyProvider.getUncheckedSigner(address);\n  }\n}\n\nexport class ImpersonatedConnector extends Connector {\n  private rpcURL: string;\n  constructor(\n    actions: Actions,\n    options: {\n      rpcUrl: string;\n    }\n  ) {\n    super(actions);\n    this.rpcURL = options.rpcUrl;\n  }\n  activate(address: string): void | Promise<void> {\n    this.actions.startActivation();\n    this.customProvider = new ImpersonatedProvider(this.rpcURL);\n    this.actions.update({\n      chainId: 1,\n      accounts: [address],\n    });\n  }\n}\n\n","import { CoinbaseWallet } from \"@web3-react/coinbase-wallet\";\nimport { initializeConnector } from \"@web3-react/core\";\nimport { MetaMask } from \"@web3-react/metamask\";\nimport type { AddEthereumChainParameter } from \"@web3-react/types\";\nimport { WalletConnect } from \"@web3-react/walletconnect\";\nimport { Connector } from '@web3-react/types';\n\nimport { ImpersonatedConnector } from \"./impersonatedConnector\";\n\nexport interface BasicChainInformation {\n  urls: string[];\n  name: string;\n}\n\nexport interface ExtendedChainInformation extends BasicChainInformation {\n  nativeCurrency: AddEthereumChainParameter[\"nativeCurrency\"];\n  blockExplorerUrls: AddEthereumChainParameter[\"blockExplorerUrls\"];\n}\n\nexport type AllConnectorsInitProps = {\n  appName: string;\n  chains: Record<number, BasicChainInformation | ExtendedChainInformation>;\n  desiredChainId: number;\n};\n\nexport const initAllConnectors = (\n  props: AllConnectorsInitProps\n) => {\n  const metaMask = initializeConnector<MetaMask>(\n    (actions) => new MetaMask({ actions })\n  );\n\n  const URLS: { [chainId: number]: string[] } = Object.keys(\n    props.chains\n  ).reduce<{ [chainId: number]: string[] }>((accumulator, chainId) => {\n    const validURLs: string[] = props.chains[Number(chainId)].urls;\n\n    if (validURLs.length) {\n      accumulator[Number(chainId)] = validURLs;\n    }\n\n    return accumulator;\n  }, {});\n\n  const walletConnect = initializeConnector<WalletConnect>(\n    (actions) =>\n      new WalletConnect({\n        actions,\n        options: {\n          rpc: URLS,\n        },\n      })\n  );\n\n  const coinbase = initializeConnector<CoinbaseWallet>(\n    (actions) =>\n      new CoinbaseWallet({\n        actions,\n        options: {\n          url: props.chains[props.desiredChainId].urls[0],\n          appName: props.appName,\n        },\n      })\n  );\n\n  const impersonatedConnector = initializeConnector<ImpersonatedConnector>(\n    (actions) =>\n      new ImpersonatedConnector(actions, {\n        rpcUrl: props.chains[props.desiredChainId].urls[0],\n      })\n  );\n\n  return [metaMask, walletConnect, coinbase, impersonatedConnector];\n};\n\n\nexport type WalletType =\n    | \"Metamask\"\n    | \"WalletConnect\"\n    | \"Coinbase\"\n    | \"Impersonated\";\n\nexport function getConnectorName(connector: Connector): WalletType | undefined {\n  if (connector instanceof MetaMask) return \"Metamask\";\n  if (connector instanceof WalletConnect) return \"WalletConnect\";\n  if (connector instanceof CoinbaseWallet) return \"Coinbase\";\n  if (connector instanceof ImpersonatedConnector) return \"Impersonated\";\n  return;\n}\n","import { BaseTx, ITransactionsState } from \"./transactionsSlice\";\n\nexport const selectAllTransactions = <T extends BaseTx>(\n  state: ITransactionsState<T>\n) => {\n  return Object.values(state.transactionsPool).sort(\n    (a, b) => a.nonce - b.nonce\n  );\n};\n\nexport const selectPendingTransactions = <T extends BaseTx>(\n  state: ITransactionsState<T>\n) => {\n  return selectAllTransactions(state).filter((tx) => tx.pending);\n};\n\nexport const selectTXByHash = <T extends BaseTx>(\n  state: ITransactionsState<T>,\n  hash: string\n) => {\n  return state.transactionsPool[hash]\n};\n","import React, { useEffect } from 'react';\nimport { UseBoundStore, StoreApi } from 'zustand';\nimport { useWeb3React, Web3ReactProvider } from '@web3-react/core';\nimport { Connector } from '@web3-react/types';\n\nimport { Wallet } from '../store/walletSlice';\nimport {\n  AllConnectorsInitProps,\n  initAllConnectors,\n  getConnectorName,\n} from '../connectors';\n\ninterface Web3ProviderProps {\n  useStore: UseBoundStore<\n    StoreApi<{\n      setActiveWallet: (wallet: Omit<Wallet, 'signer'>) => void;\n      changeActiveWalletChainId: (chainID: number) => void;\n      setConnectors: (connectors: Connector[]) => void;\n      initTxPool: () => void;\n    }>\n  >;\n  connectorsInitProps: AllConnectorsInitProps;\n}\n\nfunction Child({\n  useStore,\n  connectors,\n}: Omit<Web3ProviderProps, 'connectorsInitProps'> & {\n  connectors: Connector[];\n}) {\n  const { connector, chainId, isActive, accounts, provider } = useWeb3React();\n\n  const setActiveWallet = useStore(state => state.setActiveWallet);\n  const changeChainID = useStore(state => state.changeActiveWalletChainId);\n  const setConnectors = useStore(state => state.setConnectors);\n  const initTxPool = useStore(state => state.initTxPool);\n\n  useEffect(() => {\n    setConnectors(connectors);\n  }, [connectors]);\n\n  useEffect(() => {\n    initTxPool();\n  }, [initTxPool]);\n\n  useEffect(() => {\n    const walletType = connector && getConnectorName(connector);\n    if (walletType && accounts && isActive && provider) {\n      // TODO: don't forget to change to different\n      setActiveWallet({\n        walletType,\n        accounts,\n        chainId,\n        provider,\n        isActive,\n      });\n    }\n  }, [isActive, chainId, provider, accounts]);\n\n  useEffect(() => {\n    if (chainId) {\n      changeChainID(chainId);\n    }\n  }, [chainId]);\n  return null;\n}\n\nexport function Web3Provider({\n  useStore,\n  connectorsInitProps,\n}: Web3ProviderProps) {\n  const connectors = initAllConnectors(connectorsInitProps);\n  return (\n    <Web3ReactProvider connectors={connectors}>\n      <Child\n        useStore={useStore}\n        connectors={connectors.map(connector => connector[0])}\n      />\n    </Web3ReactProvider>\n  );\n}\n","import { ethers, providers } from \"ethers\";\n\nimport produce, { Draft } from \"immer\";\nimport { StoreSlice } from \"../../types/store\";\nimport {\n  getLocalStorageTxPool,\n  setLocalStorageTxPool,\n} from \"../../utils/localStorage\";\nimport { Web3Slice } from \"./walletSlice\";\n\nexport type BaseTx = {\n  type: string;\n  hash: string;\n  from: string;\n  to: string;\n  nonce: number;\n  payload?: object;\n  chainId: number;\n};\n\nexport type ProvidersRecord = Record<number, ethers.providers.JsonRpcProvider>;\n\nexport type TransactionPool<T extends BaseTx> = Record<string, T>;\n\nexport interface ITransactionsState<T extends BaseTx> {\n  transactionsPool: TransactionPool<\n    T & {\n      status?: number;\n      pending: boolean;\n    }\n  >;\n}\n\ninterface ITransactionsActions<T extends BaseTx> {\n  txStatusChangedCallback: (\n    data: T & {\n      status?: number;\n    }\n  ) => void;\n  executeTx: (params: {\n    body: () => Promise<ethers.ContractTransaction>;\n    params: {\n      type: T[\"type\"];\n      payload: T[\"payload\"];\n    };\n  }) => Promise<\n    T & {\n      status?: number;\n      pending: boolean;\n    }\n  >;\n  waitForTx: (hash: string) => Promise<void>;\n  updateTXStatus: (hash: string, status?: number) => void;\n  initTxPool: () => void;\n}\n\nexport type ITransactionsSlice<T extends BaseTx> = ITransactionsActions<T> &\n  ITransactionsState<T>;\n\nexport function createTransactionsSlice<T extends BaseTx>({\n  txStatusChangedCallback,\n  providers,\n}: {\n  txStatusChangedCallback: (tx: T) => void;\n  providers: ProvidersRecord;\n}): StoreSlice<\n  ITransactionsSlice<T>,\n  Pick<Web3Slice, \"checkAndSwitchNetwork\">\n> {\n  return (set, get) => ({\n    transactionsPool: {},\n    txStatusChangedCallback,\n    executeTx: async ({ body, params }) => {\n      await get().checkAndSwitchNetwork();\n      const tx = await body();\n      const chainId = Number(tx.chainId);\n      const transaction = {\n        chainId,\n        hash: tx.hash,\n        type: params.type,\n        payload: params.payload,\n        from: tx.from,\n        to: tx.to,\n        nonce: tx.nonce,\n      };\n      set((state) =>\n        produce(state, (draft) => {\n          draft.transactionsPool[transaction.hash] = {\n            ...transaction,\n            pending: true,\n          } as Draft<\n            T & {\n              pending: boolean;\n            }\n          >;\n        })\n      );\n      const txPool = get().transactionsPool;\n      setLocalStorageTxPool(txPool);\n      get().waitForTx(tx.hash);\n      return txPool[tx.hash];\n    },\n\n    waitForTx: async (hash) => {\n      const txData = get().transactionsPool[hash];\n      if (txData) {\n        const provider = providers[txData.chainId] as providers.JsonRpcProvider;\n\n        const tx = await provider.getTransaction(hash);\n        const txn = await tx.wait();\n        get().updateTXStatus(hash, txn.status);\n        const updatedTX = get().transactionsPool[hash];\n        get().txStatusChangedCallback({\n          ...updatedTX,\n        });\n      } else {\n        // TODO: no transaction in waiting pool\n      }\n    },\n    updateTXStatus: (hash, status) => {\n      set((state) =>\n        produce(state, (draft) => {\n          draft.transactionsPool[hash].status = status;\n          draft.transactionsPool[hash].pending = false;\n        })\n      );\n\n      setLocalStorageTxPool(get().transactionsPool);\n    },\n    initTxPool: () => {\n      const localStorageTXPool = getLocalStorageTxPool();\n      if (localStorageTXPool) {\n        const transactionsPool = JSON.parse(localStorageTXPool);\n        // TODO: figure out type casting from string via ZOD or similar\n        set(() => ({\n          transactionsPool,\n        }));\n      }\n      Object.values(get().transactionsPool).forEach((tx) => {\n        if (tx.pending) {\n          get().waitForTx(tx.hash);\n        }\n      });\n    },\n  });\n}\n","import type { AddEthereumChainParameter, Connector } from \"@web3-react/types\";\nimport { providers } from \"ethers\";\nimport { produce } from \"immer\";\n\nimport { StoreSlice } from \"../../types/store\";\nimport {\n  deleteLocalStorageWallet,\n  LocalStorageKeys,\n  setLocalStorageWallet,\n} from \"../../utils/localStorage\";\nimport { getConnectorName, WalletType } from '../connectors';\n\nexport interface Wallet {\n  walletType: WalletType;\n  accounts: string[];\n  chainId?: number;\n  provider: providers.JsonRpcProvider; // TODO: not correct\n  signer: providers.JsonRpcSigner; // TODO: not correct, it can be not only JsonRpc\n  // isActive is added, because Wallet can be connected but not active, i.e. wrong network\n  isActive: boolean;\n}\n\nexport type Web3Slice = {\n  activeWallet?: Wallet;\n  getActiveAddress: () => string | undefined;\n  connectWallet: (walletType: WalletType) => Promise<void>;\n  disconnectActiveWallet: () => Promise<void>;\n  walletActivating: boolean;\n  initDefaultWallet: () => Promise<void>;\n  setActiveWallet: (wallet: Omit<Wallet, \"signer\">) => void;\n  changeActiveWalletChainId: (chainId: number) => void;\n  checkAndSwitchNetwork: () => Promise<void>;\n  connectors: Connector[];\n  setConnectors: (connectors: Connector[]) => void;\n  _impersonatedAddress?: string;\n};\n\nexport function createWeb3Slice({\n  walletConnected,\n  getAddChainParameters,\n  desiredChainID = 1,\n}: {\n  walletConnected: (wallet: Wallet) => void; // TODO: why all of them here hardcoded\n  getAddChainParameters: (\n    chainId: number\n  ) => AddEthereumChainParameter | number;\n  desiredChainID?: number;\n}): StoreSlice<Web3Slice> {\n  return (set, get) => ({\n    walletActivating: false,\n    connectors: [],\n    setConnectors: (connectors) => {\n      set(() => ({ connectors }));\n      void get().initDefaultWallet();\n    },\n    initDefaultWallet: async () => {\n      const lastConnectedWallet = localStorage.getItem(\n        LocalStorageKeys.LastConnectedWallet\n      ) as WalletType | undefined;\n      if (lastConnectedWallet) {\n        await get().connectWallet(lastConnectedWallet);\n        await get().checkAndSwitchNetwork();\n      }\n    },\n    connectWallet: async (walletType: WalletType) => {\n      if (get().activeWallet?.walletType !== walletType) {\n        await get().disconnectActiveWallet();\n      }\n\n      const impersonatedAddress = get()._impersonatedAddress;\n      set({ walletActivating: true });\n      const connector = get().connectors.find(\n        connector => getConnectorName(connector) === walletType\n      );\n      if (connector) {\n        switch (walletType) {\n          case \"Impersonated\":\n            if (impersonatedAddress) {\n              await connector.activate(impersonatedAddress);\n            }\n            break;\n          case \"Coinbase\":\n          case \"Metamask\":\n            await connector.activate(\n              getAddChainParameters(desiredChainID)\n            );\n            break;\n          case \"WalletConnect\":\n            await connector.activate(desiredChainID);\n            break;\n        }\n        setLocalStorageWallet(walletType);\n      }\n      set({ walletActivating: false });\n    },\n    checkAndSwitchNetwork: async () => {\n      const activeWallet = get().activeWallet;\n      if (activeWallet) {\n        await get().connectWallet(activeWallet.walletType);\n      }\n    },\n    disconnectActiveWallet: async () => {\n      const activeWallet = get().activeWallet;\n      if (activeWallet) {\n        const activeConnector = get().connectors.find(\n          connector => getConnectorName(connector) == activeWallet.walletType\n        );\n\n        if (activeConnector?.deactivate) {\n          await activeConnector.deactivate();\n        }\n        await activeConnector?.resetState();\n        set({ activeWallet: undefined });\n      }\n      deleteLocalStorageWallet();\n    },\n    /**\n     * setActiveWallet is separate from connectWallet for a reason, after metaMask.activate()\n     * only provider is available in the returned type, but we also need accounts and chainID which for some reason\n     * is impossible to pull from .provider() still not the best approach, and I'm looking to find proper way to handle it\n     */\n    setActiveWallet: (wallet: Omit<Wallet, \"signer\">) => {\n      const providerSigner =\n        wallet.walletType == \"Impersonated\"\n          ? wallet.provider.getSigner(get()._impersonatedAddress)\n          : wallet.provider.getSigner(0);\n      set({\n        activeWallet: {\n          ...wallet,\n          signer: providerSigner,\n        },\n      });\n      const activeWallet = get().activeWallet;\n      if (activeWallet) {\n        walletConnected(activeWallet);\n      }\n    },\n    changeActiveWalletChainId: (chainId: number) => {\n      set((state) =>\n        produce(state, (draft) => {\n          if (draft.activeWallet) {\n            draft.activeWallet.chainId = chainId;\n          }\n        })\n      );\n    },\n\n    getActiveAddress: () => {\n      const activeWallet = get().activeWallet;\n      if (activeWallet && activeWallet.accounts) {\n        return activeWallet.accounts[0];\n      }\n      return undefined\n    },\n  });\n}\n"],"names":["LocalStorageKeys","setLocalStorageTxPool","pool","stringifiedPool","JSON","stringify","localStorage","setItem","TransactionPool","getLocalStorageTxPool","getItem","setLocalStorageWallet","walletType","LastConnectedWallet","deleteLocalStorageWallet","removeItem","ImpersonatedProvider","url","_this","copyProvider","providers","JsonRpcProvider","_inheritsLoose","getSigner","address","this","getUncheckedSigner","ImpersonatedConnector","actions","options","_this2","rpcURL","rpcUrl","activate","startActivation","customProvider","update","chainId","accounts","Connector","initAllConnectors","props","metaMask","initializeConnector","MetaMask","URLS","Object","keys","chains","reduce","accumulator","validURLs","Number","urls","length","WalletConnect","rpc","CoinbaseWallet","desiredChainId","appName","getConnectorName","connector","selectAllTransactions","state","values","transactionsPool","sort","a","b","nonce","Child","useStore","connectors","useWeb3React","isActive","provider","setActiveWallet","changeChainID","changeActiveWalletChainId","setConnectors","initTxPool","useEffect","connectorsInitProps","React","Web3ReactProvider","map","txStatusChangedCallback","set","get","executeTx","body","params","_context","checkAndSwitchNetwork","tx","transaction","hash","type","payload","from","to","produce","draft","pending","txPool","waitForTx","txData","_context2","getTransaction","wait","txn","updateTXStatus","status","updatedTX","localStorageTXPool","parse","forEach","walletConnected","getAddChainParameters","desiredChainID","walletActivating","initDefaultWallet","lastConnectedWallet","connectWallet","activeWallet","disconnectActiveWallet","impersonatedAddress","_impersonatedAddress","find","_context3","_context4","activeConnector","deactivate","resetState","undefined","wallet","providerSigner","signer","getActiveAddress","filter"],"mappings":"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"}